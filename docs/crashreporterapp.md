# CrashReporterApp

The `CrashReporterApp` provides a simple example program on how to register for
unhandled exceptions, and how to register a watchdog. It is intended for
providing a very simple example and as an integration test for the CrashReporter
library.

## Unhandled Exceptions

Run the program with the single option

```text
CrashReportApp.exe exception

RJCP.CrashReporter Information: 0 : Crash dump created at: C:\Users\jcurl\AppData\Local\CrashDumps\CrashReportApp-20200119120159.2e161246-b00a-4907-8952-e5ac4f5cff9a.zip

Unhandled Exception: System.InvalidOperationException: An exception which should cause a dump
   at CrashReportApp.Program.Main(String[] args) in C:\Users\jcurl\Documents\Programming\HELIOS\helios.devfxio\framework\crashreporter\CrashReportApp\Program.cs:line 28
```

It will generate a simple dump in the same directory where the program is run
from, and cause an unhandled exception `InvalidOperationException`. The log file
can be found in `%LOCALAPPDATA%\CrashDumps` as a zip file. The `App.Config` file
contains an entry to print crash information to the console, so that when the
crash is generated by the exception, the location of the zipped dump is printed.

Open the compressed crash and there should be:

* An XML file for the crash
* An XSL stylesheet so that the XML can be loaded with most browsers
* A core dump, which when copied to the same location of where the
  `CrashReportApp` was started and opened with Visual Studio, one can look at
  the cause of the crash.

On Mono for Linux, core dumps are not generated.

## Watchdog Timeout

Run the program with the single option

```text
CrashReportApp.exe watchdog

RJCP.CrashReporter Verbose: 0 : Watchdog warning created at: C:\Users\jcurl\AppData\Local\CrashDumps\CrashReportApp.wd-20200119120236.839de4cf-f3c6-4db9-b8a3-eb466424f195.zip
RJCP.CrashReporter Information: 0 : Watchdog error created at: C:\Users\jcurl\AppData\Local\CrashDumps\CrashReportApp.wderr-20200119120239.36338b34-22e7-4dbc-9052-9efa81407e44.zip
```

The watchdog `app` is registered with a warning of 2 seconds, and a timeout of 5
seconds. The main thread is blocked for 10 seconds. This should cause two
additional crash dumps, both which are printed to the console based on the
configuration in the `App.config` file.

Opening the `CrashReporterApp.exe.wd-xxxx.zip` file will contain a crash dump
(XML and XSL) but no core dump (this would cause noticeable delays otherwise).
About 3 seconds later there is a second dump called
`CrashReportApp.exe.wderr-xxxx.zip` which contains further traces about the
watchdog error and a core dump of the application at the time of the watchdog
error.

## Test Scenarios

The tool can also be used to do some simplified manual tests that are not
trivial as part of unit testing:

### Default Exception Handling

Run the tool as seen above for "Unhandled Exceptions".

Check for the following:

* The log file `CrashDump.xml` and `CrashDump.xsl` is in the current directory.
  Inspecting the contents should contain a single trace line indicating the
  program has started.
* There should be a new log file in `%LOCALAPPDATA%\CrashDumps`, the precise
  name is printed to the console output. Open this file and ensure that there is
  a crash dump (Windows only) and that information about the exception is logged
  in addition in the XML file. The exception should be printed twice:
  * An `Information` for the `FirstChanceException`, and `Critical` for an
    `UnhandledException` (it's critical as the program is about to end).
  * The `Source` should be the `CrashReportApp` as the application provided this
    in an override (so it is logged in the XML and not logged to the console
    which would be lost when providing bug reports to the developer in real
    scenarios).

### Default Watchdog Handling

Run the tool as seen above for "Watchdog Handling".

Check for the following:

* There should be two log files generated. They have the names (the xxxx is the
  timestamp and a unique extension to not overwrite existing files):
  * `CrashReportApp.exe.wd-xxxx.zip` (watchdog warning); and
  * `CrashReportApp.exe.wderr-xxxx.zip` (watchdog error).
* The watchdog warning should contain the following entries for the source
  `RJCP.CrashReporter.Watchdog`:
  * `Information` when the watchdog is registered; and
  * `Warning` when the watchdog warning time expired (2000ms). The timestamp in
    the message is the local time, while the timestamp of the log itself is UTC.
  * There is no core dump in this case.
* The watchdog error should cause the program to stop after about 5 seconds. It
  should contain the following entries for the source
  `RJCP.CrashReporter.Watchdog`:
  * The same as the watchdog warning in the previous log
  * `Error` when the timeout occurs (5000ms). The format of the message is
    similar to a watchdog warning.

Watchdog warnings and errors occur on different threads (using the
`System.Threading.Timer` object) and so have a different thread id to the rest
of the program. But the `Thread` text in the message can be used to know which
thread performed the last ping, helping to track down the problem.

In the watchdog error, one can load the `CrashReportApp.xxx.dmp` file and debug
managed only to see the state of the threads. In this test, it should be obvious
that the main thread is blocked on the sleep operation, which is the cause of
the watchdog timeout.

### Disabling Logging

For .NET Framework 4.x, modify the file `CrashReportApp.exe.config` to remove
all logging. Remove the section `<system.diagnostics>` and inner tags
completely. Rerun the tests above.

For .NET Core, logging is initialized in code, see the file `Log.cs`. The
external library `RJCP.Diagnostics.Trace` is responsible for creating the
internal `TraceListener` that wraps around the user `ILogger` (you need to
instantiate where to log to yourself in your own code).

Running `CrashReportApp.exe exception` generates a crash dump, but there are no
traces in crash. To find the crash, go to `%LOCALAPPDATA%\CrashDumps` and find
the most recent crash. It won't be printed to the console, as logging is
removed. There should still be a minidump to help debugging (just that now the
contextual information is missing).

Open the minidump and ensure the crash is at the exception. The location of the
stack at the time of the crash is at the code which caused the minidump, but
going over the stack will show the root cause to be the exception:

```text
Not Flagged    >    9056    0    Main Thread    Main Thread
RJCP.Diagnostics.CrashReporter.dll!RJCP.Diagnostics.Dump.Core.MiniDump
[Managed to Native Transition]
RJCP.Diagnostics.CrashReporter.dll!RJCP.Diagnostics.Dump.Core.MiniDump(string path, RJCP.Diagnostics.Dump.CoreType dumpType) Line 91
RJCP.Diagnostics.CrashReporter.dll!RJCP.Diagnostics.CrashReporter.CreateDump(string fileName, RJCP.Diagnostics.Dump.CoreType coreType) Line 327
RJCP.Diagnostics.CrashReporter.dll!RJCP.Diagnostics.CrashReporter.CreateDump() Line 254
RJCP.Diagnostics.CrashReporter.dll!RJCP.Diagnostics.CrashReporter.UnhandledExceptionHandler(object sender, System.UnhandledExceptionEventArgs args) Line 237
[Native to Managed Transition]
[Managed to Native Transition]
CrashReportApp.exe!CrashReportApp.Program.Main(string[] args) Line 28
```

The last line is the location of the exception.

Similarly, running `CrashReportApp.exe watchdog` should still generate two
crashes, one for the watchdog warning, the other for the watchdog error. Go to
`%LOCALAPPDATA%\CrashDumps` and find the two most recent crashes. It won't be
printed to the console as logging is removed.

The warning should not contain any logs, and is probably less useful (other than
the warning occurred).

The watchdog error should contain a dump that can be loaded with a debugger.
Observe that the watchdog error can be identified with one of the stack frames
on the `Thread.Sleep(10000)` instruction.
